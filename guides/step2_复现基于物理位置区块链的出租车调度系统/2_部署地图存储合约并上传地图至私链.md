### 链上地图基本结构分析
- 地图是由各种地图元素构成（道路，地铁站，路口等）
- 不同的元素有不同属性（几何形状，长度、起点终点等）
- 把地图按照geoHash编码划分成若干区域，每个geoHash区域内都有一些元素
### 合约代码简析
> 前人的合约代码经过笔者的修整可以在新的环境下编译，详见`doc/`目录下的[StoreMap合约文件改动记录](../../doc/StoreMap%E5%90%88%E7%BA%A6%E6%96%87%E4%BB%B6%E6%94%B9%E5%8A%A8%E8%AE%B0%E5%BD%95.md)。修整后的合约在[这里](../../src/uploadmap/StoreMap.sol)。
#### 状态变量说明
- 每个元素`one_element`包含：`minzoom`显示需要的最小缩放、`cost`路径长度（如果有）、`oneway`是否是一条路、`building`是否是建筑物、`highway`是什么级别的公路、`name`元素的名称、`source`起点坐标、`target`终点坐标、`gtype`[几何形状](https://www.rfc-editor.org/rfc/rfc7946#section-1.4)、`path_num`途经点的数量、`path`途经点的坐标
- 全部元素集合`all_elements`
- 每个geoHash地区`area`包含：`num`该地区中元素的数量、`element_index`地区中元素在`all_elements`中的索引
- 用geoHash划分的整个地图`geo_maps`
- 一个导航合约的实例`nav`
#### 函数说明
- `constructor`构造函数，只在合约部署时执行一次：
    ```
    constructor() {
        //创建一个新的导航合约实例，将返回其地址
		nav = new Navigation();
	}
    ```
- `add_one_element`为地图新增一个元素：
    ```
    function add_one_element(uint32 gid, uint32 minzoom, uint32 cost, uint32 source, uint32 target, bool oneway, bool building, bytes32 highway, bytes32 name, bytes32 gtype, bytes32[] memory path) public {
        //gid是新元素的索引（序号）
		all_elements[gid].minzoom = minzoom;
		all_elements[gid].cost = cost;
		all_elements[gid].source = source;
		all_elements[gid].target = target;
		all_elements[gid].oneway = oneway;
		all_elements[gid].building = building;
		all_elements[gid].highway = highway;
		all_elements[gid].name = name;
		all_elements[gid].gtype = gtype;
		
		//更新节点邻居信息以便导航
		nav.add_one_peer(cost, path[0], path[path.length - 1]);

        //更新元素的路径点位置（如果是道路的话将有很多路径点）
		uint32 num = all_elements[gid].path_num;
		for(uint32 i=0; i< path.length; i++){
			all_elements[gid].path[num++] = path[i];
		}
		all_elements[gid].path_num = num;
	}
    ```
- `add_area_element`将元素分配到地图某geohash区域：
    ```
    function add_area_element(bytes32 hash, uint32 gid) public {
		uint32 num = geo_maps[hash].num++;              //该区域元素数量加一
		geo_maps[hash].element_index[num] = gid;        //该区域的第num号元素是第pid号元素
	}
    ```
- 一些暂时保留的导航接口：
    ```
    //导航函数，根据起终位置输出导航路径及距离
    function astar(bytes32 startGeohash, bytes32 endGeohash) public returns(bytes32[] memory backwards, uint32 costAll){
		return nav.astar(startGeohash, endGeohash);
	}
    //修改导航的精度（geohash编码的位数）
	function changePrecision(uint32 newPrecision) public returns (uint32){
		return nav.changePrecision(newPrecision);
	}
    //修改导航算法的参数
	function changeP(uint32 newP) public returns (uint32){
		return nav.changeP(newP);
	}
    ```

    注意事项:
    - 笔者不对导航算法进行过多解释，详情请看[成佳壮的导航算法开发文档](../../reference/investigation-cjzhuang2020/%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3.md)
### 部署地图存储合约
### 测试合约基本功能