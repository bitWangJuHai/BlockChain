### 确认环境
```
Ubuntu：22.04.2 LTS
geth1.9.12：1.9.12-stable
geth1：
    Version: 1.9.12-stable
    Git Commit: 27356db60e570e51169f6c763ff14eb41abc9e56
    Git Commit Date: 20210721
    Architecture: amd64
    Protocol Versions: [65 64 63]
    Go Version: go1.13.9
    Operating System: linux
node：18.15.0
npm-solc：0.8.19+commit.7dd6d404.Emscripten.clang
npm-web3：1.9.0
```
### 链上地图基本结构分析
- 地图是由各种地图元素构成（道路，地铁站，路口等）
- 不同的元素有不同属性（几何形状，长度、起点终点等）
- 将所有元素按照序号顺序存储起来
- 把地图按照geoHash编码划分成若干区域，建立一个区域到区域内元素的映射
### 合约代码简析
> 前人的合约代码经过笔者的修整可以在新的环境下编译，详见`doc/`目录下的[StoreMap合约文件改动记录](../../doc/StoreMap%E5%90%88%E7%BA%A6%E6%96%87%E4%BB%B6%E6%94%B9%E5%8A%A8%E8%AE%B0%E5%BD%95.md)。修整后的合约在[这里](../../src/uploadmap/StoreMap.sol)。
#### 状态变量说明
- 每个元素`one_element`包含：`minzoom`显示需要的最小缩放、`cost`路径长度（如果有）、`oneway`是否是一条路、`building`是否是建筑物、`highway`是什么级别的公路、`name`元素的名称、`source`起点坐标、`target`终点坐标、`gtype`[几何形状](https://www.rfc-editor.org/rfc/rfc7946#section-1.4)、`path_num`途经点的数量、`path`途经点的坐标
- 全部元素集合`all_elements`
- 每个geoHash地区`area`包含：`num`该地区中元素的数量、`element_index`地区中元素在`all_elements`中的索引
- 用geoHash划分的整个地图`geo_maps`
- 一个导航合约的实例`nav`
#### 函数说明
- `constructor`构造函数，只在合约部署时执行一次：
    ```
    constructor() {
        //创建一个新的导航合约实例，将返回其地址
		nav = new Navigation();
	}
    ```
- `get_elements`获取某geohash范围内所有的元素：
	```
	function get_elements(bytes32 hash) view public returns (uint32[] memory feature, bytes32[] memory names, bytes32[] memory highways, bytes32[] memory gtypes, bytes32[] memory path) {
		uint32 num = geo_maps[hash].num;
		uint32 path_num = 0;
		uint32 i = 0;
		uint32 j = 0;

		if(num > 0){
			feature = new uint32[](7 * num);
			names = new bytes32[]( num );
			highways = new bytes32[]( num );
			gtypes = new bytes32[]( num );
			uint32 gid;
			for(i = 0; i < num; i++){
				//从元素集合内获得该元素
				gid = geo_maps[hash].element_index[i]; 
				one_element storage ele1 = all_elements[gid];
				//将一些元素放到返回值内
				uint32 base = i * 7;
				feature[base] = gid;
				feature[base + 1] = ele1.minzoom;
				feature[base + 2] = ele1.cost;
				feature[base + 3] = ele1.source;
				feature[base + 4] = ele1.target;
				if(ele1.oneway){
					feature[base + 5] = 1;
				}
				else{
					feature[base + 5] = 0;
				}
				if(ele1.building){
					feature[base + 6] = 1;
				}
				else{
					feature[base + 6] = 0;
				}
				names[i] = ele1.name;
				highways[i] = ele1.highway;
				gtypes[i] = ele1.gtype;
				//总路径点数增加
				path_num = path_num + 1 + ele1.path_num;
			}

			//根据总路径点数量形成全体路径点的数组
			path = new bytes32[](path_num);
			uint32 pos = 0;
			for(i = 0; i < num; i++){
				gid = geo_maps[hash].element_index[i];
				one_element storage ele2 = all_elements[gid];
				for(j = 0; j < ele2.path_num; j++){
					path[pos++] = ele2.path[j];
				}
			}
		}
	}
	```
- `add_one_element`为地图新增一个元素：
    ```
    function add_one_element(uint32 gid, uint32 minzoom, uint32 cost, uint32 source, uint32 target, bool oneway, bool building, bytes32 highway, bytes32 name, bytes32 gtype, bytes32[] memory path) public {
        //gid是新元素的索引（序号）
		all_elements[gid].minzoom = minzoom;
		all_elements[gid].cost = cost;
		all_elements[gid].source = source;
		all_elements[gid].target = target;
		all_elements[gid].oneway = oneway;
		all_elements[gid].building = building;
		all_elements[gid].highway = highway;
		all_elements[gid].name = name;
		all_elements[gid].gtype = gtype;
		
		//更新节点邻居信息以便导航
		nav.add_one_peer(cost, path[0], path[path.length - 1]);

        //更新元素的路径点位置（如果是道路的话将有很多路径点）
		uint32 num = all_elements[gid].path_num;
		for(uint32 i=0; i< path.length; i++){
			all_elements[gid].path[num++] = path[i];
		}
		all_elements[gid].path_num = num;
	}
    ```
- `add_area_element`将元素分配到地图某geohash区域：
    ```
    function add_area_element(bytes32 hash, uint32 gid) public {
		uint32 num = geo_maps[hash].num++;              //该区域元素数量加一
		geo_maps[hash].element_index[num] = gid;        //该区域的第num号元素是第pid号元素
	}
    ```
- 一些暂时保留的导航接口：
    ```
    //导航函数，根据起终位置输出导航路径及距离
    function astar(bytes32 startGeohash, bytes32 endGeohash) public returns(bytes32[] memory backwards, uint32 costAll){
		return nav.astar(startGeohash, endGeohash);
	}
    //修改导航的精度（geohash编码的位数）
	function changePrecision(uint32 newPrecision) public returns (uint32){
		return nav.changePrecision(newPrecision);
	}
    //修改导航算法的参数
	function changeP(uint32 newP) public returns (uint32){
		return nav.changeP(newP);
	}
    ```

    注意事项:
    - 笔者不对导航算法进行过多解释，详情请看[成佳壮的导航算法开发文档](../../reference/investigation-cjzhuang2020/%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3.md)
### 部署地图存储合约
> 部署脚本在[这里](../../src/contract_on_system/deploy%26uploadmap.js)，代码做了比较详细的注释，有兴趣的读者请自行阅读
#### 脚本说明
- 本脚本目前只支持上传道路（LineString）类型的地图元素
- 调整参数后使用`node <脚本>`直接执行
- 交通存储合约一并部署，想了解其代码详情请看下一节
#### 参数调整
- `map_file`：要上传的地图文件，行4
- `storeMapCode`：地图存储合约代码，行10
- `storeMapImportCode`：导航合约代码，行11
- `storeTrafficCode`：交通存储合约代码，行12
- `web3`：本地web3实例，行48
- `accounts[0]`：合约的部署者，需要有足够的以太币，需要手动在js控制台内解锁